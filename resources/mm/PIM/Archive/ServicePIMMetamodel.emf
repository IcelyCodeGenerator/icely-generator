@namespace(uri="platform:/resource/MyCore/resources/mm/PIM/ServicePIMMetamodel.ecore", prefix="mde")
package ServicePIM;

import "platform:/resource/MyCore/resources/mm/PIM/SecurityPIMMetamodel.ecore";
import "platform:/resource/MyCore/resources/mm/PIM/QueryPIMMetamodel.ecore";

class Resource {
	!unique attr boolean[1] isAlgorithmic;
	id attr String[1] name;
	val InputRepresentation[+] hasInputRepresentation;
	val CRUDActivity[+] hasActivities;
	val OutputRepresentation[+] hasOutputRepresentation;
	val QueryPIM.Filter[*] filters;
	val QueryPIM.Select[*] select;
	val QueryPIM.ScopeSearch[*] scopesearch;
	val QueryPIM.Caching caching;
	ref DTO[1] model;
	ref Resource[*] hasRelatedResource;
	ref Resource[*] isRelatedResource;
}

class Property {
	attr boolean[1] isUnique;
	attr boolean[1] isNamingProperty;
	attr String[1] name;
	attr boolean[1] isRequired = true;
	attr int min;
	attr int max;
	ref TypeDefinition[1] type;
	attr String[1] typeName;
}

class InputRepresentation {
	!unique attr MediaType[1] inputMediaType;
}

class OutputRepresentation {
	!unique attr MediaType[1] outputMediaType;
}

enum MediaType {
	JSON = 0;
	XML = 1;
}

@Ecore(constraints="UniqueResourceNames")
class RESTfulServicePIM {
	id attr String[1] name;
	attr String[1] basePath;
	val Application[+] hasApplications;
	val SecurityPIM.Role[*] hasRoles;
	val PrimitiveType[*] primitiveTypes;
}

class Relation {
	!unique attr Multiplicity[1] multiplicity;
	ref DomainObject[1] target;
	ref DomainObject[1] source;
	!unique attr String cascade;
	!unique attr String orderBy;
	!unique attr String visibility;
	!unique attr boolean required;
	!unique attr boolean nullable;
	attr boolean many;
}

enum Multiplicity {
	ONE_TO_MANY = 0;
	MANY_TO_ONE = 1;
	ONE_TO_ONE = 2;
	MANY_TO_MANY = 3;
}

enum ApplicationType {
	MICROSERVICE = 0;
	GATEWAY = 1;
	MONOLITH = 2;
}

class Application {
	val Config[1] hasConfig;
	val Resource[+] resources;
	val QueryPIM.GlobalSearch globalsearches;
	ref SecurityPIM.Role[*] roles;
	val Deployment[*] deployment;
	val Aggregate[*] aggregates;
	val Service[*] services;
	val Enumeration[*] enumerations;
	val DataMapper[*] datamapper;
	attr String name;
}

class Config {
	id attr String[1] baseName;
	attr ApplicationType[1] applicationType;
	attr String[1] servicePort;
}

abstract class TypeDefinition {
	id attr String[1] typeName;
}

class Enumeration extends DomainObject {
	val Literal[+] literals;
}

class BasicType extends ValueObject {
}

class Literal {
	id attr String[1] name;
	attr int[1] value;
}

enum DefaultType {
	String = 0;
	Integer = 1;
	Float = 2;
	Boolean = 3;
	null = 4;
	Date = 5;
}

class CRUDActivity extends Operation {
	attr boolean isAuthenticatedRequired;
	attr boolean isCustom;
	ref Service delegate;
}

class Create extends CRUDActivity {
}

class Read extends CRUDActivity {
}

class Update extends CRUDActivity {
}

class Delete extends CRUDActivity {
}

class Deployment {
	attr DatabaseType dbType;
	attr String dbUsername;
	attr String dbIP;
	attr String dbPassword;
	attr String dbPort;
	attr DeploymentType deploymentType;
	attr String directoryPath;
	attr String[1] name;
}

enum DeploymentType {
	DOCKER = 0;
	KUBERNETES = 1;
	OPENSHIFT = 2;
}

enum DatabaseType {
	SQL = 0;
	MONGODB = 1;
	CASSANDRA = 2;
	COUCHBASE = 3;
	NO = 4;
}

class Entity extends DomainObject {
	attr boolean scaffold;
}

class DataMapper {
	ref Entity[+] entity;
	ref DTO[1] dto;
	attr String name;
}

class DTO extends ValueObject {
}

abstract class DomainObject extends TypeDefinition {
	val Property[*] hasProperty;
	attr String name;
	attr boolean ~abstract;
	val Repository#aggregateRoot repository;
	!unique attr boolean aggregateRoot = true;
	val DomainObjectOperation[*]#domainObject operations;
	val Relation[*] hasRelationship;
}

class ValueObject extends DomainObject {
	attr boolean immutable;
	attr boolean persistent;
}

class Aggregate {
	val DomainObject[*] domainobjects;
	attr String name;
}

class Operation {
	val Parameter[*] parameters;
	ref TypeDefinition returnType;
	attr String name;
	ref Publish publish;
}

class Parameter {
	ref TypeDefinition type;
	attr String name;
}

class CollectionResource extends Resource {
	val QueryPIM.Pagination pagination;
	val QueryPIM.Sort[*] sort;
}

class SingletonResource extends Resource {
	attr String lookupField;
}

abstract class Event extends ValueObject {
}

class Publish {
	!unique attr String eventBus;
	!unique attr String topic;
	ref Event eventType;
}

class CommandEvent extends Event {
}

class DomainEvent extends Event {
}

class ServiceOperation extends Operation {
	ref ServiceOperation serviceDelegate;
	ref RepositoryOperation delegate;
	ref Service[1]#operations service;
}

class DomainObjectOperation extends Operation {
	!unique attr boolean ~abstract;
	ref DomainObject[1]#operations domainObject;
}

class RepositoryOperation extends Operation {
	!unique attr boolean delegateToAccessObject = false;
	!unique attr String accessObjectName;
	ref Repository[1]#operations repository;
}

class Repository {
	ref Repository[*] repositoryDependencies;
	attr String[*] otherDependencies;
	ref DomainObject#repository aggregateRoot;
	val RepositoryOperation[*]#repository operations;
	ref Subscribe subscribe;
}

class Service {
	ref Repository[*] repositoryDependencies;
	attr String[*] otherDependencies;
	ref Service[*] serviceDependencies;
	!unique attr boolean webService;
	!unique attr boolean remoteInterface = true;
	!unique attr boolean localInterface = true;
	ref Subscribe subscribe;
	val ServiceOperation[*]#service operations;
}

class Subscribe {
	!unique attr String eventBus;
	!unique attr String topic;
}

class PrimitiveType extends TypeDefinition {
	attr DefaultType type;
}

